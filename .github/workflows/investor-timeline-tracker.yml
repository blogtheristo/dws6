name: Investor Timeline Tracker

on:
  schedule:
    # Run on the 1st and 15th of each month at 9:00 AM UTC
    - cron: '0 9 1,15 * *'
  workflow_dispatch:
    inputs:
      days_ahead:
        description: 'Number of days to look ahead for upcoming deadlines'
        required: false
        default: '30'
        type: string

permissions:
  contents: read
  issues: write

jobs:
  check-timeline:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install python-dateutil

      - name: Parse timeline and create issues
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DAYS_AHEAD: ${{ github.event.inputs.days_ahead || '30' }}
        run: |
          python3 << 'EOF'
          import os
          import re
          import json
          from datetime import datetime, timedelta
          from dateutil import parser as date_parser
          import subprocess

          # Read the timeline file
          with open('investor-timeline.md', 'r') as f:
              content = f.read()

          # Current date and look-ahead window
          today = datetime.now()
          days_ahead = int(os.environ.get('DAYS_AHEAD', '30'))
          end_date = today + timedelta(days=days_ahead)

          print(f"Checking for deadlines between {today.date()} and {end_date.date()}")
          print("-" * 60)

          # Define month mapping
          months = {
              'January': 1, 'February': 2, 'March': 3, 'April': 4,
              'May': 5, 'June': 6, 'July': 7, 'August': 8,
              'September': 9, 'October': 10, 'November': 11, 'December': 12
          }

          # Parse timeline entries
          entries = []
          current_quarter = None
          current_month = None

          lines = content.split('\n')
          i = 0
          while i < len(lines):
              line = lines[i].strip()

              # Track current quarter
              if line.startswith('## Q') and '2026' in line:
                  current_quarter = line
                  i += 1
                  continue

              # Track current month
              if line.startswith('### ') and '2026' in line:
                  current_month = line.replace('### ', '').strip()
                  i += 1
                  continue

              # Parse deadline entries (lines starting with -)
              if line.startswith('- **') and current_month:
                  # Extract the deadline text
                  deadline_match = re.match(r'- \*\*([^*]+)\*\*', line)
                  if deadline_match:
                      deadline_text = deadline_match.group(1).strip()

                      # Try to parse the date
                      deadline_date = None

                      # Pattern 1: "Month Day: Description"
                      date_match = re.match(r'([A-Za-z]+)\s+(\d+):\s*(.+)', deadline_text)
                      if date_match:
                          month_name = date_match.group(1)
                          day = date_match.group(2)
                          description = date_match.group(3)

                          if month_name in months:
                              try:
                                  deadline_date = datetime(2026, months[month_name], int(day))
                              except ValueError:
                                  pass

                      # Pattern 2: "Early/Mid/Late Month: Description"
                      elif re.match(r'(Early|Mid|Late)\s+([A-Za-z]+):\s*(.+)', deadline_text):
                          timing_match = re.match(r'(Early|Mid|Late)\s+([A-Za-z]+):\s*(.+)', deadline_text)
                          timing = timing_match.group(1)
                          month_name = timing_match.group(2)
                          description = timing_match.group(3)

                          if month_name in months:
                              # Estimate dates: Early=5th, Mid=15th, Late=25th
                              day_mapping = {'Early': 5, 'Mid': 15, 'Late': 25}
                              try:
                                  deadline_date = datetime(2026, months[month_name], day_mapping[timing])
                              except ValueError:
                                  pass

                      # Pattern 3: "Month Day-Day: Description" (date ranges)
                      elif re.match(r'([A-Za-z]+)\s+(\d+)-(\d+):\s*(.+)', deadline_text):
                          range_match = re.match(r'([A-Za-z]+)\s+(\d+)-(\d+):\s*(.+)', deadline_text)
                          month_name = range_match.group(1)
                          day_start = range_match.group(2)
                          description = range_match.group(4)

                          if month_name in months:
                              try:
                                  deadline_date = datetime(2026, months[month_name], int(day_start))
                              except ValueError:
                                  pass

                      if deadline_date:
                          # Collect multi-line details
                          details = []
                          j = i + 1
                          while j < len(lines):
                              next_line = lines[j].strip()
                              if next_line.startswith('- ') and not next_line.startswith('  -'):
                                  break
                              if next_line.startswith('  - ') or next_line.startswith('  Contact:') or next_line.startswith('  Action:') or next_line.startswith('  Target:') or next_line.startswith('  Amount:') or next_line.startswith('  Focus:'):
                                  details.append(next_line)
                              j += 1

                          entries.append({
                              'date': deadline_date,
                              'title': deadline_text,
                              'quarter': current_quarter,
                              'month': current_month,
                              'details': '\n'.join(details)
                          })

              i += 1

          # Filter entries within the look-ahead window
          upcoming_entries = [
              e for e in entries
              if today <= e['date'] <= end_date
          ]

          # Sort by date
          upcoming_entries.sort(key=lambda x: x['date'])

          print(f"Found {len(upcoming_entries)} upcoming deadlines:")
          print()

          # Create GitHub issues for upcoming deadlines
          for entry in upcoming_entries:
              days_until = (entry['date'] - today).days

              issue_title = f"[Investor Timeline] {entry['title']}"
              issue_body = f"""## Deadline: {entry['date'].strftime('%B %d, %Y')} ({days_until} days from now)

          **Quarter:** {entry['quarter']}
          **Month:** {entry['month']}

          ### Details:
          {entry['details']}

          ---

          *This issue was automatically created by the Investor Timeline Tracker workflow.*
          *Source: [investor-timeline.md](../blob/main/investor-timeline.md)*
          """

              print(f"✓ {entry['date'].strftime('%Y-%m-%d')} - {entry['title']}")

              # Check if issue already exists
              check_cmd = [
                  'gh', 'issue', 'list',
                  '--state', 'all',
                  '--search', f'"{issue_title}"',
                  '--json', 'number,title,state',
                  '--limit', '1'
              ]

              try:
                  result = subprocess.run(check_cmd, capture_output=True, text=True, check=True)
                  existing_issues = json.loads(result.stdout)

                  if existing_issues:
                      issue_number = existing_issues[0]['number']
                      issue_state = existing_issues[0]['state']
                      print(f"  → Issue #{issue_number} already exists (state: {issue_state})")

                      # Reopen if closed
                      if issue_state == 'CLOSED':
                          reopen_cmd = ['gh', 'issue', 'reopen', str(issue_number)]
                          subprocess.run(reopen_cmd, check=True)
                          print(f"  → Reopened issue #{issue_number}")
                  else:
                      # Create new issue
                      create_cmd = [
                          'gh', 'issue', 'create',
                          '--title', issue_title,
                          '--body', issue_body,
                          '--label', 'investor-timeline'
                      ]
                      result = subprocess.run(create_cmd, capture_output=True, text=True, check=True)
                      print(f"  → Created new issue: {result.stdout.strip()}")

              except subprocess.CalledProcessError as e:
                  print(f"  → Error managing issue: {e}")
                  print(f"  → stderr: {e.stderr}")

          if not upcoming_entries:
              print("No upcoming deadlines found in the specified time window.")

          print()
          print("-" * 60)
          print("Timeline check complete!")
          EOF

      - name: Generate summary
        run: |
          echo "## Investor Timeline Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Checked for deadlines in the next ${{ github.event.inputs.days_ahead || '30' }} days" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "See the workflow logs for details on created/updated issues." >> $GITHUB_STEP_SUMMARY
